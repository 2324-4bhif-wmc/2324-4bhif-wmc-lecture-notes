= 23/24 4bhif wmc - Lecture Notes
ifndef::imagesdir[:imagesdir: images]
:icons: font
:experimental:
:sectnums:
:toc:
ifdef::backend-html5[]

// https://fontawesome.com/v4.7.0/icons/
icon:file-text-o[link=https://github.com/2324-4bhif-wmc/2324-4bhif-wmc-lecture-notes/main/asciidocs/{docname}.adoc] ‏ ‏ ‎
icon:github-square[link=https://github.com/2324-4bhif-wmc/2324-4bhif-wmc-lecture-notes] ‏ ‏ ‎
icon:home[link=http://edufs.edu.htl-leonding.ac.at/~t.stuetz/hugo/2021/01/lecture-notes/]
endif::backend-html5[]

== 2023-09-18


=== Intro microprofile

https://htl-leonding-college.github.io/quarkus-lecture-notes/


|===
|Name |Thema

|Aichinger Tobias
|Elektrohandel

|Al Desoky Abdullah
|Fitness-Ratgeber

|Balazs Bálint
|Kochrezept

|Berg Bajtik
|Schwimmwettkampf

|Breinesberger Markus
|Friedhofsverwaltung

|Cao Anton
|Restaurant

|Cvijić Luka
|Autohändler

|Daxinger Oliver
|Dienstplan für Straßenmeisterei

|Fröller Felix
|Autoverleih

|Gruber Moritz
|Tennisverein

|Ilming Winnie
|Bilbliothek

|Lehner David
|Bauernhof (Planung der Felder, Was wird angebaut)

|Mali Laurent
|Fussballverein

|Nestler Linus
|Zoo

|Nikolaus Alexander
|Christkindl-Vw

|Nurceski Said
|Kino

|Salkovic Armin
|Reisebusunternehmen

|Schludermann Julian
|Zug (Welche Linien, Fahrplan)

|Schnalzenberger Arwed
|Gärtnerei

|Seifried Erik
|Fussball-Liga (welches Team spielt gegen welches mit Mannschaften mit sämtlichen Ereignissen während eines Spiels)

|Sonnleitner Lukas
|Fahrschule

|===


* Application Server
** Web-Server für Java Applikationen
** Mit einem Java Application Server können Java Programme "ins Internet gebracht werden"
** Bsp: Glassfish (Referenzimplementierung), Payara, Wildfly, ...




== 2023-09-25 REST-Service

IMPORTANT: Internet für Prozesse und Maschinen

=== REST-clients

* Browser (für GET)
* Browser-Plugins (für GET, POST, DELETE, PUT, PATCH, ...)
* Programme wie Postman, Insomnia, ...
* REST-Client in der IDE
* Test-Apis wie RestAssured, Karate,...
* CLI-clients wir curl, httpie, ...
* ...

==== Verschiedene Ausgaben für identes GET möglich

* durch Angabe eines unterschiedlichen MediaTypes

==== ConfigProperty

* Variablen können auf verschiedene Arten einen Wert erhalten

https://quarkus.io/guides/config-reference[^]

image::confi-properties.png[]



=== HÜ

* Für eine Klasse (Stammdaten) einen Rest-Endpoint erstellen mit CRUD-Funktionalität, der die Daten in einer List speichert.

== 2023-10-02 REST - Resources and caching

=== Cashing Explanation

==== Cashing
* Es gibt Server und Clients
* Jedes mal, wenn ein Client etwas benötigt, setzt er einen Request an den Server ab
* Da kann schon was zusammen kommen

==== Browser
* HTTP1.1 sagt: Jeder Browser darf nur maximal 2 Connections pro Webpage offen haben
* Chrome hat ein Limit von 6 pro remote- site und 10 über den gesamten Browser
* Wenn man da auf viele kleine Antworten wartet, dann kann das zu Verstopfungen führen

==== Lösung
* Ich (der Client) hole mir nicht immer das allerneueste Objekt vom Backend, sondern gebe mich mit einem etwas älteren zufrieden. (-> weniger Requests)
* Der Server schickt nur ein neues Objekt, falls sich die Antwort seit der letzten Anfrage geändert hat (sonst nicht)
* Geht natürlich nur bei GET Requests

=== Expires

==== Feld im HTTP-Header
* Ich biete als Server eine Resource an
* Wenn ich eine Response schicke, hänge ich ein Header-Feld an

image::http-bsp.png[]

* Der Client weiß jetzt, dass er vor diesem Timestamp nicht nochmal fragen braucht
* Der Client gibt in diesem Fall dem Programmierer die 'alte' Antwort (passiert in Clients automatisch)
* Ansonsten holt sich der Client eine neue Resource ab (mit neuem expires-Feld)

==== Expires
* Eingestellt am Server
** Muss sich mal wer überlegen
** Kann sich auch ändern
* Passiert dann eigentlich im Client
* Ist für den Entwickler 'transparent'
* Der Entwickler macht einen einen Request, der Client merkt sich die Antworten per Resource (URL)
* Spart die komplette Übertragung des Requests und des Responses

==== Beispiel:
image::expires-bsp.png[]

=== E-Tag Hashing

==== E-Tag
* Ich biete am Server eine Resource an
* Wenn ich eine Resource schicke, hänge ich einen Hash-Wert an, der eindeutig ist für diese 'Version' der Antwort
* Wenn ein Client die Resource anfragt, schickt er den Hash-Wert mit
* Am Server: Wenn der Hash-Wert der Antwort sich mit dem mitgeschickten Hash-Wert deckt, dann schicke ich einfach den HTTP-Status-Code: *304 - Not Modified*
* Spart eigentlich 'nur' die Rückübertragung der Daten im body des Responses (wenn es sich nicht verändert hat)

===== Beispiel:
image::etag-bsp.png[]

=== HTTP status ranges in a nutshell
image::nutshell-bsp.png[]